#!/usr/bin/env python
# -*-coding: utf-8 -*-
#Copyright (c) 2017 Iecas Inc. All rights reserved.
#edit by zdh 
#
#
#  https://www.regex101.com/ 不解释 谁用谁知道
#  no space! 多个空格就显示不出来了

USAGE = '''
正则表达式主要分为四部分：
1、预编译（预选择项）
2、限定项
3、追加项
4、特殊意义项


1、主要为（）类型的匹配 分为两种：
    一、精确匹配值,，（123）就是匹配123，一个都不能差，用来区别哥们中括号[]，
    二、预编译 也就是说在开始先排除一波错误答案～
　　（pattern）  精确匹配括号内值pattern  eg:（123） 就是匹配123 而[123] 能匹配1、2、3（单独的）
     预编译--官方解释为以下都是非获取的 不显示结果      
    （?:pattern） 精确匹配值pattern，非捕获 用于区别没有？的情况——捕获组  
    二者的区别就是  不带？的  只能搞一次  带了？ 以后还能接着查
    eg:  s = "abc"
    a(?=b)bc,s   可以匹配s   因为b可以再查一次  显示为abc（非捕获组） 
    a(b)bc,s   不可以匹配s  因为b已经匹配过了  只能显示abbc（捕获组）

  
    （?=pattern） 正向预查  精确匹配pattern
      eg:  ^.*(?=95|98|NT|2000).*$  
     ^.*开头所有显示  .*$结尾所有显示  限定符：95|98|NT|2000 如果有限定符 则从开头到结尾都显示 
    （?!pattern） 正向预查  精确否定pattern 与上面相反
    
    方向反一下 重后面开始   
    （?<=pattern）  (?<=95|98|NT|2000)windows   显示后面的windows
    （?<!pattern）
    
2、主要限定匹配时的位置与“敏感性”匹配
    \b  元字符 匹配单词边界 --   \B  相反 
    . 元字符   除\n任意字符  常用（.|\n）代表所有    
    ^  开头   $ 结尾
    [pattern]  匹配[]内部拥有的  eg[123]  -- 1 2 3 任意一个都可以
    正则中[]内  ^代表非的意思  [^abc]
    
    特殊含义：
    \cx ctrl+x
    \d   [0-9] \D 反过来
    \w   [a-z0-9A-Z]  \W 反过来
    \f \r \n \t \v C语言 换页 回车 换行 制表符（tab） 垂直制表符（不知道是谁）
    \s  空白字符（无显示的） =[\f\n\r\t\v] \S 相反
    \uXX  XX 的Unicode字符
    \xXX  XX 的16进制符
 
 3、追加  顾名思义 追加对前面选项的拓展意义
 
  * + ？三兄弟   0-无穷 1-无穷 0-1
  再精确点----{}出现   {n} {n,} {n,m}  n次  n-无穷次 n-m次
  再精确点----？跟在前面两句话词儿的后面(eg：*,+,?，{n}，{n,}，{n,m})  ---> 越少越好
        敲重点：正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：
                最先开始的匹配拥有最高的优先权——The match that begins earliest wins。
                a.*?b--aabab    ans is   aab  & ab
  再精确点----\num   eg:   (.)\1  匹配两个连续的相同字符
  
'''